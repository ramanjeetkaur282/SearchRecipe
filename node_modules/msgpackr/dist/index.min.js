(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e=e||self,t(e.msgpackr={}))})(this,function(e){"use strict";var t=Math.floor;function n(e){try{if(!F.trusted&&!q){let e=M.sharedLength||0;e<M.length&&(M.length=e)}let t;if(F.randomAccessStructure&&64>R[z]&&32<=R[z]&&Y?(t=Y(R,z,E,F),R=null,!(e&&e.lazy)&&t&&(t=t.toJSON()),z=E):t=s(),C&&(// bundled strings to skip past
z=C.postBundlePosition),z==E)M?.restoreStructures&&r(),M=null,R=null,D&&(D=null);else if(z>E)// over read
throw new Error("Unexpected end of MessagePack data");else if(!q)throw new Error("Data read, but end of buffer not reached "+JSON.stringify(t).slice(0,100));// else more to read, but we are reading sequentially, so don't clear source yet
return t}catch(e){throw M?.restoreStructures&&r(),m(),(e instanceof RangeError||e.message.startsWith("Unexpected end of buffer")||z>E)&&(e.incomplete=!0),e}}function r(){for(let e in M.restoreStructures)M[e]=M.restoreStructures[e];M.restoreStructures=null}function s(){let e=R[z++];if(160>e){if(!(128>e)){if(!(144>e)){e-=144;let t=Array(e);for(let n=0;n<e;n++)t[n]=s();return F.freezeData?Object.freeze(t):t}if(e-=128,F.mapsAsObjects){let t={};for(let n,r=0;r<e;r++)n=h(),"__proto__"===n&&(n="__proto_"),t[n]=s();return t}else{let t=new Map;for(let n=0;n<e;n++)t.set(s(),s());return t}}else if(64>e)return e;else{let t=M[63&e]||F.getStructures&&o()[63&e];return t?(t.read||(t.read=i(t,63&e)),t.read()):e}}else if(192>e){// fixstr
let t=e-160;if(N>=z)return B.slice(z-P,(z+=t)-P);if(0==N&&140>E){// for small blocks, avoiding the overhead of the extract call is helpful
let e=16>t?g(t):c(t);if(null!=e)return e}return K(t)}else{let t;switch(e){case 192:return null;case 193:return C?(t=s(),0<t?C[1].slice(C.position1,C.position1+=t):C[0].slice(C.position0,C.position0-=t)):W;// "never-used", return special object to denote that
case 194:return!1;case 195:return!0;case 196:if(t=R[z++],void 0===t)throw new Error("Unexpected end of buffer");return l(t);case 197:return t=T.getUint16(z),z+=2,l(t);case 198:return t=T.getUint32(z),z+=4,l(t);case 199:// ext 8
return f(R[z++]);case 200:return t=T.getUint16(z),z+=2,f(t);case 201:return t=T.getUint32(z),z+=4,f(t);case 202:if(t=T.getFloat32(z),2<F.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let e=ie[(127&R[z])<<1|R[z+1]>>7];return z+=4,(e*t+(0<t?.5:-.5)>>0)/e}return z+=4,t;case 203:return t=T.getFloat64(z),z+=8,t;// uint handlers
case 204:return R[z++];case 205:return t=T.getUint16(z),z+=2,t;case 206:return t=T.getUint32(z),z+=4,t;case 207:return F.int64AsNumber?(t=4294967296*T.getUint32(z),t+=T.getUint32(z+4)):t=T.getBigUint64(z),z+=8,t;// int handlers
case 208:return T.getInt8(z++);case 209:return t=T.getInt16(z),z+=2,t;case 210:return t=T.getInt32(z),z+=4,t;case 211:return F.int64AsNumber?(t=4294967296*T.getInt32(z),t+=T.getUint32(z+4)):t=T.getBigInt64(z),z+=8,t;case 212:if(t=R[z++],114==t)return ne(63&R[z++]);else{let e=j[t];if(e)return e.read?(z++,e.read(s())):e.noBuffer?(z++,e()):e(R.subarray(z,++z));throw new Error("Unknown extension "+t)}case 213:return t=R[z],114==t?(z++,ne(63&R[z++],R[z++])):f(2);case 214:// fixext 4
return f(4);case 215:// fixext 8
return f(8);case 216:// fixext 16
return f(16);case 217:return t=R[z++],N>=z?B.slice(z-P,(z+=t)-P):Q(t);case 218:return t=T.getUint16(z),z+=2,N>=z?B.slice(z-P,(z+=t)-P):X(t);case 219:return t=T.getUint32(z),z+=4,N>=z?B.slice(z-P,(z+=t)-P):Z(t);case 220:return t=T.getUint16(z),z+=2,u(t);case 221:return t=T.getUint32(z),z+=4,u(t);case 222:return t=T.getUint16(z),z+=2,d(t);case 223:return t=T.getUint32(z),z+=4,d(t);default:// negative int
if(224<=e)return e-256;if(void 0===e){let e=new Error("Unexpected end of MessagePack data");throw e.incomplete=!0,e}throw new Error("Unknown MessagePack token "+e);}}}function i(e,t){function n(){// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
if(n.count++>$){let n=e.read=new Function("r","return function(){return "+(F.freezeData?"Object.freeze":"")+"({"+e.map(e=>"__proto__"===e?"__proto_:r()":G.test(e)?e+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"})}")(s);return 0===e.highByte&&(e.read=H(t,e.read)),n();// second byte is already read, if there is one so immediately read object
}let r={};for(let t,n=0,i=e.length;n<i;n++)t=e[n],"__proto__"===t&&(t="__proto_"),r[t]=s();return F.freezeData?Object.freeze(r):r}return n.count=0,0===e.highByte?H(t,n):n}function o(){let e=y(()=>(R=null,F.getStructures()));return M=F._mergeStructures(e,M)}function a(e){let t;if(16>e&&(t=g(e)))return t;if(64<e&&x)return x.decode(R.subarray(z,z+=e));const n=z+e,r=[];for(t="";z<n;){const e=R[z++];if(0==(128&e))r.push(e);else if(192==(224&e)){// 2 bytes
const t=63&R[z++];r.push((31&e)<<6|t)}else if(224==(240&e)){// 3 bytes
const t=63&R[z++],n=63&R[z++];r.push((31&e)<<12|t<<6|n)}else if(240==(248&e)){// 4 bytes
const t=63&R[z++],n=63&R[z++],s=63&R[z++];let i=(7&e)<<18|t<<12|n<<6|s;65535<i&&(i-=65536,r.push(55296|1023&i>>>10),i=56320|1023&i),r.push(i)}else r.push(e);4096<=r.length&&(t+=ee.apply(String,r),r.length=0)}return 0<r.length&&(t+=ee.apply(String,r)),t}function u(e){let t=Array(e);for(let n=0;n<e;n++)t[n]=s();return F.freezeData?Object.freeze(t):t}function d(e){if(F.mapsAsObjects){let t={};for(let n,r=0;r<e;r++)n=h(),"__proto__"===n&&(n="__proto_"),t[n]=s();return t}else{let t=new Map;for(let n=0;n<e;n++)t.set(s(),s());return t}}function c(e){let t=z,n=Array(e);for(let r=0;r<e;r++){const e=R[z++];if(0<(128&e))return void(z=t);n[r]=e}return ee.apply(String,n)}function g(t){if(4>t){if(!(2>t)){let e=R[z++],n=R[z++];if(0<(128&e)||0<(128&n))return void(z-=2);if(3>t)return ee(e,n);let r=R[z++];return 0<(128&r)?void(z-=3):ee(e,n,r)}if(0===t)return"";else{let e=R[z++];return 1<(128&e)?void(z-=1):ee(e)}}else{let r=R[z++],s=R[z++],a=R[z++],u=R[z++];if(0<(128&r)||0<(128&s)||0<(128&a)||0<(128&u))return void(z-=4);if(6>t){if(4===t)return ee(r,s,a,u);else{let t=R[z++];return 0<(128&t)?void(z-=5):ee(r,s,a,u,t)}}else if(8>t){let n=R[z++],e=R[z++];if(0<(128&n)||0<(128&e))return void(z-=6);if(7>t)return ee(r,s,a,u,n,e);let i=R[z++];return 0<(128&i)?void(z-=7):ee(r,s,a,u,n,e,i)}else{let d=R[z++],e=R[z++],c=R[z++],g=R[z++];if(0<(128&d)||0<(128&e)||0<(128&c)||0<(128&g))return void(z-=8);if(10>t){if(8===t)return ee(r,s,a,u,d,e,c,g);else{let t=R[z++];return 0<(128&t)?void(z-=9):ee(r,s,a,u,d,e,c,g,t)}}else if(12>t){let n=R[z++],i=R[z++];if(0<(128&n)||0<(128&i))return void(z-=10);if(11>t)return ee(r,s,a,u,d,e,c,g,n,i);let o=R[z++];return 0<(128&o)?void(z-=11):ee(r,s,a,u,d,e,c,g,n,i,o)}else{let p=R[z++],i=R[z++],f=R[z++],h=R[z++];if(0<(128&p)||0<(128&i)||0<(128&f)||0<(128&h))return void(z-=12);if(!(14>t)){let l=R[z++],y=R[z++];if(0<(128&l)||0<(128&y))return void(z-=14);if(15>t)return ee(r,s,a,u,d,e,c,g,p,i,f,h,l,y);let n=R[z++];return 0<(128&n)?void(z-=15):ee(r,s,a,u,d,e,c,g,p,i,f,h,l,y,n)}if(12===t)return ee(r,s,a,u,d,e,c,g,p,i,f,h);else{let t=R[z++];return 0<(128&t)?void(z-=13):ee(r,s,a,u,d,e,c,g,p,i,f,h,t)}}}}}function p(){let e,t=R[z++];if(192>t)// fixstr
e=t-160;else switch(t){case 217:e=R[z++];break;case 218:e=T.getUint16(z),z+=2;break;case 219:e=T.getUint32(z),z+=4;break;default:throw new Error("Expected string");}return a(e)}function l(e){return F.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(R,z,z+=e):R.subarray(z,z+=e)}function f(e){let t=R[z++];if(j[t]){let n;return j[t](R.subarray(z,n=z+=e),e=>{z=e;try{return s()}finally{z=n}})}throw new Error("Unknown extension type "+t)}function h(){let e=R[z++];if(160<=e&&192>e){if(e-=160,N>=z)// if it has been extracted, must use it (and faster anyway)
return B.slice(z-P,(z+=e)-P);if(!(0==N&&180>E))return K(e)}else return z--,s();let t,n=4095&(e<<5^(1<e?T.getUint16(z):0<e?R[z]:0)),r=te[n],o=z,a=z+e-3,u=0;if(r&&r.bytes==e){for(;o<a;){if(t=T.getUint32(o),t!=r[u++]){o=1879048192;break}o+=4}for(a+=3;o<a;)if(t=R[o++],t!=r[u++]){o=1879048192;break}if(o===a)return z=o,r.string;a-=3,o=z}for(r=[],te[n]=r,r.bytes=e;o<a;)t=T.getUint32(o),r.push(t),o+=4;for(a+=3;o<a;)t=R[o++],r.push(t);// for small blocks, avoiding the overhead of the extract call is helpful
let d=16>e?g(e):c(e);return null==d?r.string=K(e):r.string=d}// the registration of the record definition extension (as "r")
// notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>
function y(e){let t=E,n=z,r=P,s=N,i=B,o=D,a=C,u=new Uint8Array(R.slice(0,E)),d=M,c=M.slice(0,M.length),g=F,p=q,l=e();return E=t,z=n,P=r,N=s,B=i,D=o,C=a,R=u,q=p,M=d,M.splice(0,M.length,...c),F=g,T=new DataView(R.buffer,R.byteOffset,R.byteLength),l}function m(){R=null,D=null,M=null}function b(e){j[e.type]=e.unpack?e.unpack:e}function S(e,t,n){let r=e.byteLength;if(256>r+1){var{target:s,position:i}=n(4+r);s[i++]=199,s[i++]=r+1}else if(65536>r+1){var{target:s,position:i}=n(5+r);s[i++]=200,s[i++]=r+1>>8,s[i++]=255&r+1}else{var{target:s,position:i,targetView:o}=n(7+r);// plus one for the type byte
s[i++]=201,o.setUint32(i,r+1),i+=4}// "t" for typed array
s[i++]=116,s[i++]=t,s.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength),i)}function k(e,t){let n=e.byteLength;var r,s;if(256>n){var{target:r,position:s}=t(n+2);r[s++]=196,r[s++]=n}else if(65536>n){var{target:r,position:s}=t(n+3);r[s++]=197,r[s++]=n>>8,r[s++]=255&n}else{var{target:r,position:s,targetView:i}=t(n+5);r[s++]=198,i.setUint32(s,n),s+=4}r.set(e,s)}function U(e,t,n,r){let s=e.length;return 1===s?t[n++]=212:2===s?t[n++]=213:4===s?t[n++]=214:8===s?t[n++]=215:16===s?t[n++]=216:256>s?(t[n++]=199,t[n++]=s):65536>s?(t[n++]=200,t[n++]=s>>8,t[n++]=255&s):(t[n++]=201,t[n++]=s>>24,t[n++]=255&s>>16,t[n++]=255&s>>8,t[n++]=255&s),t[n++]=r,t.set(e,n),n+=s,n}function _(e,t){// insert the ids that need to be referenced for structured clones
let n,r=6*t.length,s=e.length-r;for(t.sort((e,t)=>e.offset>t.offset?1:-1);n=t.pop();){let t=n.offset,i=n.id;e.copyWithin(t+r,t,s),r-=6;let o=t+r;// 'i'
e[o++]=214,e[o++]=105,e[o++]=i>>24,e[o++]=255&i>>16,e[o++]=255&i>>8,e[o++]=255&i,s=t}return e}function I(e,t){if(0<we.length){_e.setUint32(we.position+e,Ae-we.position-e);let n=we;we=null,t(n[0]),t(n[1])}}function O(e){if(e.Class){if(!e.pack&&!e.write)throw new Error("Extension has no pack or write function");if(e.pack&&!e.type)throw new Error("Extension has no type (numeric code to identify the extension)");he.unshift(e.Class),fe.unshift(e)}b(e)}function A(e,t){return e.isCompatible=e=>{let n=!e||(t.lastNamedStructuresLength||0)===e.length;return n||// we want to merge these existing structures immediately since we already have it and we are in the right transaction
t._mergeStructures(e),n},e}function*w(e,t){const n=new xe(t);for(const r of e)yield n.pack(r)}async function*L(e,t){const n=new xe(t);for await(const r of e)yield n.pack(r)}/**
	 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
	 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
	 * @param {object} [options] - unpackr options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
	 */var x;try{x=new TextDecoder}catch(e){}var R,E,M,B,C,D,T,z=0,F={},P=0,N=0,j=[],V={useRecords:!1,mapsAsObjects:!0};class v{}const W=new v;W.name="MessagePack 0xC1";var Y,q=!1,$=2;try{new Function("")}catch(e){// if eval variants are not supported, do not create inline object readers ever
$=1/0}class J{constructor(e){e&&(!1===e.useRecords&&e.mapsAsObjects===void 0&&(e.mapsAsObjects=!0),e.sequential&&!1!==e.trusted&&(e.trusted=!0,!e.structures&&!1!=e.useRecords&&(e.structures=[],!e.maxSharedStructures&&(e.maxSharedStructures=0))),e.structures?e.structures.sharedLength=e.structures.length:e.getStructures&&((e.structures=[]).uninitialized=!0,e.structures.sharedLength=0)),Object.assign(this,e)}unpack(e,t){if(R)// re-entrant execution, save the state and restore it after we do this unpack
return y(()=>(m(),this?this.unpack(e,t):J.prototype.unpack.call(V,e,t)));"object"==typeof t?(E=t.end||e.length,z=t.start||0):(z=0,E=-1<t?t:e.length),N=0,B=null,C=null,R=e;// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
// technique for getting data from a database where it can be copied into an existing buffer instead of creating
// new ones
try{T=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(t){if(R=null,e instanceof Uint8Array)throw t;throw new Error("Source must be a Uint8Array or Buffer but was a "+(e&&"object"==typeof e?e.constructor.name:typeof e))}if(this instanceof J){if(F=this,this.structures)return M=this.structures,n(t);(!M||0<M.length)&&(M=[])}else F=V,(!M||0<M.length)&&(M=[]);return n(t)}unpackMultiple(e,t){let r,s=0;try{q=!0;let i=e.length,o=this?this.unpack(e,i):oe.unpack(e,i);if(t){for(t(o);z<i;)if(s=z,!1===t(n()))return;}else{for(r=[o];z<i;)s=z,r.push(n());return r}}catch(e){throw e.lastPosition=s,e.values=r,e}finally{q=!1,m()}}_mergeStructures(e,t){e=e||[],Object.isFrozen(e)&&(e=e.map(e=>e.slice(0)));for(let n,r=0,s=e.length;r<s;r++)n=e[r],n&&(n.isShared=!0,32<=r&&(n.highByte=r-32>>5));for(let n in e.sharedLength=e.length,t||[])if(0<=n){let r=e[n],s=t[n];s&&(r&&((e.restoreStructures||(e.restoreStructures=[]))[n]=r),e[n]=s)}return this.structures=e}decode(e,t){return this.unpack(e,t)}}const G=/^[a-zA-Z_$][a-zA-Z\d_$]*$/,H=(e,t)=>function(){let n=R[z++];if(0===n)return t();let r=32>e?-(e+(n<<5)):e+(n<<5),s=M[r]||o()[r];if(!s)throw new Error("Record id is not defined for "+r);return s.read||(s.read=i(s,e)),s.read()};var K=a,Q=a,X=a,Z=a;var ee=String.fromCharCode,te=Array(4096);const ne=(e,t)=>{let n;if(F.freezeData){F.freezeData=!1;try{n=s()}finally{F.freezeData=!0}}else n=s();let r=e;void 0!==t&&(e=32>e?-((t<<5)+e):(t<<5)+e,n.highByte=t);let o=M[e];return o&&o.isShared&&((M.restoreStructures||(M.restoreStructures=[]))[e]=o),M[e]=n,n.read=i(n,r),n.read()};j[0]=()=>{},j[0].noBuffer=!0,j[101]=()=>{let e=s();return(globalThis[e[0]]||Error)(e[1])},j[105]=()=>{// id extension (for structured clones)
let e=T.getUint32(z-4);D||(D=new Map);let t,n=R[z];t=144<=n&&160>n||220==n||221==n?[]:{};let r={target:t};// a placeholder object
D.set(e,r);let i=s();// read the next value as the target object to id
return r.used?Object.assign(t,i):(r.target=i,i);// no cycle, can just use the returned read object
},j[112]=()=>{// pointer extension (for structured clones)
let e=T.getUint32(z-4),t=D.get(e);return t.used=!0,t.target},j[115]=()=>new Set(s());const re=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(e=>e+"Array");j[116]=e=>{let t=e[0],n=re[t];if(!n)throw new Error("Could not find typed array for code "+t);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new globalThis[n](Uint8Array.prototype.slice.call(e,1).buffer)},j[120]=()=>{let e=s();return new RegExp(e[0],e[1])};const se=[];j[98]=e=>{let t=(e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3],n=z;return z+=t-e.length,C=se,C=[p(),p()],C.position0=0,C.position1=0,C.postBundlePosition=z,z=n,s()},j[255]=e=>4==e.length?new Date(1e3*(16777216*e[0]+(e[1]<<16)+(e[2]<<8)+e[3])):8==e.length?new Date(((e[0]<<22)+(e[1]<<14)+(e[2]<<6)+(e[3]>>2))/1e6+1e3*(4294967296*(3&e[3])+16777216*e[4]+(e[5]<<16)+(e[6]<<8)+e[7])):12==e.length?new Date(((e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3])/1e6+1e3*((128&e[4]?-281474976710656:0)+1099511627776*e[6]+4294967296*e[7]+16777216*e[8]+(e[9]<<16)+(e[10]<<8)+e[11])):new Date("invalid");const ie=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let n=0;256>n;n++)ie[n]=+("1e"+t(45.15-.30103*n));var oe=new J({useRecords:!1});const ae=oe.unpack,ue=oe.unpackMultiple,de=oe.unpack,ce={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let ge,pe=new Float32Array(1),le=new Uint8Array(pe.buffer,0,4);try{ge=new TextEncoder}catch(e){}let fe,he;const ye="undefined"!=typeof Buffer,me=ye?function(e){return Buffer.allocUnsafeSlow(e)}:Uint8Array,be=ye?Buffer:Uint8Array,Se=ye?4294967296:2144337920;let ke,Ue,_e,Ie,Oe,Ae=0,we=null;const Le=Symbol("record-id");class xe extends J{constructor(e){super(e),this.offset=0;let t,n,r,s,i=be.prototype.utf8Write?function(e,t){return ke.utf8Write(e,t,4294967295)}:!!(ge&&ge.encodeInto)&&function(e,t){return ge.encodeInto(e,ke.subarray(t)).written},o=this;e||(e={});let a=e&&e.sequential,u=e.structures||e.saveStructures,d=e.maxSharedStructures;if(null==d&&(d=u?32:0),8160<d)throw new Error("Maximum maxSharedStructure is 8160");e.structuredClone&&null==e.moreTypes&&(e.moreTypes=!0);let c=e.maxOwnStructures;null==c&&(c=u?32:64),this.structures||!1==e.useRecords||(this.structures=[]);// two byte record ids for shared structures
let g=32<d||64<c+d,p=d+64,l=d+c+64;if(8256<l)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let f=[],h=0,y=0;this.pack=this.encode=function(e,i){if(ke||(ke=new me(8192),_e=ke.dataView=new DataView(ke.buffer,0,8192),Ae=0),Ie=ke.length-10,2048>Ie-Ae?(ke=new me(ke.length),_e=ke.dataView=new DataView(ke.buffer,0,ke.length),Ie=ke.length-10,Ae=0):Ae=2147483640&Ae+7,t=Ae,s=o.structuredClone?new Map:null,o.bundleStrings&&"string"!=typeof e?(we=[],we.size=1/0):we=null,r=o.structures,r){r.uninitialized&&(r=o._mergeStructures(o.getStructures()));let e=r.sharedLength||0;if(e>d)//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids
throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+r.sharedLength);if(!r.transitions){r.transitions=Object.create(null);for(let t,n=0;n<e;n++){if(t=r[n],!t)continue;let e,s=r.transitions;for(let n,r=0,i=t.length;r<i;r++)n=t[r],e=s[n],e||(e=s[n]=Object.create(null)),s=e;s[Le]=n+64}this.lastNamedStructuresLength=e}a||(r.nextId=e+64)}n&&(n=!1);try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(o.randomAccessStructure&&e.constructor&&e.constructor===Object?w(e):m(e),we&&I(t,m),o.offset=Ae,s&&s.idsToInsert){Ae+=6*s.idsToInsert.length,Ae>Ie&&S(Ae),o.offset=Ae;let e=_(ke.subarray(t,Ae),s.idsToInsert);return s=null,e}return i&ze?(ke.start=t,ke.end=Ae,ke):ke.subarray(t,Ae);// position can change if we call pack again in saveStructures, so we get the buffer now
}finally{if(r){10>y&&y++;let s=r.sharedLength||0;if(r.length>s&&(r.length=s),1e4<h)r.transitions=null,y=0,h=0,0<f.length&&(f=[]);else if(0<f.length&&!a){for(let e=0,t=f.length;e<t;e++)f[e][Le]=0;f=[]}if(n&&o.saveStructures){// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
let n=ke.subarray(t,Ae),i=A(r,o);return!1===o.saveStructures(i,i.isCompatible)?o.pack(e):(o.lastNamedStructuresLength=s,n)}}i&Fe&&(Ae=t)}};const m=e=>{Ae>Ie&&(ke=S(Ae));var n,r=typeof e;if("string"==r){let r=e.length;if(we&&4<=r&&4096>r){if((we.size+=r)>61440){let e,n=(we[0]?3*we[0].length+we[1].length:0)+10;Ae+n>Ie&&(ke=S(Ae+n)),we.position?(ke[Ae]=200,Ae+=3,ke[Ae++]=98,e=Ae-t,Ae+=4,I(t,m),_e.setUint16(e+t-3,Ae-t-e)):(ke[Ae++]=214,ke[Ae++]=98,e=Ae-t,Ae+=4),we=["",""],we.size=0,we.position=e}let n=/[\u0080-\uFFFF]/.test(e);return we[n?0:1]+=e,ke[Ae++]=193,void m(n?-r:r)}let s=32>r?1:256>r?2:65536>r?3:5;// first we estimate the header size, so we can write to the correct location
let o=3*r;if(Ae+o>Ie&&(ke=S(Ae+o)),64>r||!i){let t,i,o,a=Ae+s;for(t=0;t<r;t++)i=e.charCodeAt(t),128>i?ke[a++]=i:2048>i?(ke[a++]=192|i>>6,ke[a++]=128|63&i):55296==(64512&i)&&56320==(64512&(o=e.charCodeAt(t+1)))?(i=65536+((1023&i)<<10)+(1023&o),t++,ke[a++]=240|i>>18,ke[a++]=128|63&i>>12,ke[a++]=128|63&i>>6,ke[a++]=128|63&i):(ke[a++]=224|i>>12,ke[a++]=128|63&i>>6,ke[a++]=128|63&i);n=a-Ae-s}else n=i(e,Ae+s);32>n?ke[Ae++]=160|n:256>n?(2>s&&ke.copyWithin(Ae+2,Ae+1,Ae+1+n),ke[Ae++]=217,ke[Ae++]=n):65536>n?(3>s&&ke.copyWithin(Ae+3,Ae+2,Ae+2+n),ke[Ae++]=218,ke[Ae++]=n>>8,ke[Ae++]=255&n):(5>s&&ke.copyWithin(Ae+5,Ae+3,Ae+3+n),ke[Ae++]=219,_e.setUint32(Ae,n),Ae+=4),Ae+=n}else if("number"===r){if(e>>>0===e)32>e||128>e&&!1===this.useRecords||64>e&&!this.randomAccessStructure?ke[Ae++]=e:256>e?(ke[Ae++]=204,ke[Ae++]=e):65536>e?(ke[Ae++]=205,ke[Ae++]=e>>8,ke[Ae++]=255&e):(ke[Ae++]=206,_e.setUint32(Ae,e),Ae+=4);else if(e>>0===e)-32<=e?ke[Ae++]=256+e:-128<=e?(ke[Ae++]=208,ke[Ae++]=e+256):-32768<=e?(ke[Ae++]=209,_e.setInt16(Ae,e),Ae+=2):(ke[Ae++]=210,_e.setInt32(Ae,e),Ae+=4);else{let t;if(0<(t=this.useFloat32)&&4294967296>e&&-2147483648<=e){ke[Ae++]=202,_e.setFloat32(Ae,e);let n;if(4>t||// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(n=e*ie[(127&ke[Ae])<<1|ke[Ae+1]>>7])>>0===n)return void(Ae+=4);// move back into position for writing a double
Ae--}ke[Ae++]=203,_e.setFloat64(Ae,e),Ae+=8}}else if("object"===r){if(!e)ke[Ae++]=192;else{if(s){let n=s.get(e);if(n){if(!n.id){let e=s.idsToInsert||(s.idsToInsert=[]);n.id=e.push(n)}return ke[Ae++]=214,ke[Ae++]=112,_e.setUint32(Ae,n.id),void(Ae+=4)}s.set(e,{offset:Ae-t})}let r=e.constructor;if(r===Object)b(e,!0);else if(r===Array){n=e.length,16>n?ke[Ae++]=144|n:65536>n?(ke[Ae++]=220,ke[Ae++]=n>>8,ke[Ae++]=255&n):(ke[Ae++]=221,_e.setUint32(Ae,n),Ae+=4);for(let t=0;t<n;t++)m(e[t])}else if(r===Map){n=e.size,16>n?ke[Ae++]=128|n:65536>n?(ke[Ae++]=222,ke[Ae++]=n>>8,ke[Ae++]=255&n):(ke[Ae++]=223,_e.setUint32(Ae,n),Ae+=4);for(let[t,n]of e)m(t),m(n)}else{for(let t,n=0,r=fe.length;n<r;n++)if(t=he[n],e instanceof t){let t=fe[n];if(t.write)return t.type&&(ke[Ae++]=212,ke[Ae++]=t.type,ke[Ae++]=0),void m(t.write.call(this,e));let r=ke,s=_e,i=Ae;ke=null;let o;try{o=t.pack.call(this,e,e=>(ke=r,r=null,Ae+=e,Ae>Ie&&S(Ae),{target:ke,targetView:_e,position:Ae-e}),m)}finally{r&&(ke=r,_e=s,Ae=i,Ie=ke.length-10)}return void(o&&(o.length+Ae>Ie&&S(o.length+Ae),Ae=U(o,ke,Ae,t.type)))}// no extension found, write as object
b(e,!e.hasOwnProperty)}}}else if("boolean"===r)ke[Ae++]=e?195:194;else if("bigint"===r){if(e<BigInt(1)<<BigInt(63)&&e>=-(BigInt(1)<<BigInt(63)))ke[Ae++]=211,_e.setBigInt64(Ae,e);else if(e<BigInt(1)<<BigInt(64)&&0<e)ke[Ae++]=207,_e.setBigUint64(Ae,e);else// overflow
if(this.largeBigIntToFloat)ke[Ae++]=203,_e.setFloat64(Ae,+e);else throw new RangeError(e+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");Ae+=8}else if("undefined"===r)this.encodeUndefinedAsNil?ke[Ae++]=192:(ke[Ae++]=212,ke[Ae++]=0,ke[Ae++]=0);else if("function"===r)m(this.writeFunction&&this.writeFunction());else throw new Error("Unknown type: "+r)},b=!1===this.useRecords?this.variableMapSize?e=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let t=Object.keys(e),n=t.length;16>n?ke[Ae++]=128|n:65536>n?(ke[Ae++]=222,ke[Ae++]=n>>8,ke[Ae++]=255&n):(ke[Ae++]=223,_e.setUint32(Ae,n),Ae+=4);let r;for(let s=0;s<n;s++)m(r=t[s]),m(e[r])}:(e,n)=>{ke[Ae++]=222;// always using map 16, so we can preallocate and set the length afterwards
let r=Ae-t;Ae+=2;let s=0;for(let t in e)(n||e.hasOwnProperty(t))&&(m(t),m(e[t]),s++);ke[r++ +t]=s>>8,ke[r+t]=255&s}:e.progressiveRecords&&!g?// this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
(e,n)=>{let s,i,o=r.transitions||(r.transitions=Object.create(null)),a=Ae++-t;for(let u in e)if(n||e.hasOwnProperty(u)){if(s=o[u],s)o=s;else{// record doesn't exist, create full new record and insert it
let n=Object.keys(e),d=o;o=r.transitions;let c=0;for(let e,t=0,r=n.length;t<r;t++)e=n[t],s=o[e],s||(s=o[e]=Object.create(null),c++),o=s;a+t+1==Ae?(Ae--,k(o,n,c)):// otherwise we need to insert the record, moving existing data after the record
O(o,n,a,c),i=!0,o=d[u]}m(e[u])}if(!i){let n=o[Le];n?ke[a+t]=n:O(o,Object.keys(e),a,0)}}:(e,t)=>{let n,s=r.transitions||(r.transitions=Object.create(null)),i=0;for(let r in e)(t||e.hasOwnProperty(r))&&(n=s[r],n||(n=s[r]=Object.create(null),i++),s=n);let o=s[Le];// now write the values
for(let n in o?96<=o&&g?(ke[Ae++]=(31&(o-=96))+96,ke[Ae++]=o>>5):ke[Ae++]=o:k(s,s.__keys__||Object.keys(e),i),e)(t||e.hasOwnProperty(n))&&m(e[n])},S=e=>{var n=Math.min,r=Math.round,s=Math.max;let i;if(16777216<e){// special handling for really large buffers
if(e-t>Se)throw new Error("Packed buffer would be larger than maximum buffer size");i=n(Se,4096*r(s((e-t)*(67108864<e?1.25:2),4194304)/4096))}else// faster handling for smaller buffers
i=(s(e-t<<2,ke.length-1)>>12)+1<<12;let o=new me(i);return _e=o.dataView=new DataView(o.buffer,0,i),e=n(e,ke.length),ke.copy?ke.copy(o,0,t,e):o.set(ke.slice(t,e)),Ae-=t,t=0,Ie=o.length-10,ke=o},k=(e,t,s)=>{let i=r.nextId;i||(i=64),i<p&&this.shouldShareStructure&&!this.shouldShareStructure(t)?(i=r.nextOwnId,!(i<l)&&(i=p),r.nextOwnId=i+1):(i>=l&&(// cycle back around
i=p),r.nextId=i+1);let o=t.highByte=96<=i&&g?i-96>>5:-1;e[Le]=i,e.__keys__=t,r[i-64]=t,i<p?(t.isShared=!0,r.sharedLength=i-63,n=!0,0<=o?(ke[Ae++]=(31&i)+96,ke[Ae++]=o):ke[Ae++]=i):(0<=o?(ke[Ae++]=213,ke[Ae++]=114,ke[Ae++]=(31&i)+96,ke[Ae++]=o):(ke[Ae++]=212,ke[Ae++]=114,ke[Ae++]=i),s&&(h+=y*s),f.length>=c&&(f.shift()[Le]=0),f.push(e),m(t))},O=(e,n,r,s)=>{let i=ke,o=Ae,a=Ie,u=t;ke=Ue,Ae=0,t=0,ke||(Ue=ke=new me(8192)),Ie=ke.length-10,k(e,n,s),Ue=ke;let d=Ae;if(ke=i,Ae=o,Ie=a,t=u,1<d){let e=Ae+d-1;e>Ie&&S(e);let n=r+t;ke.copyWithin(n+d,n+1,Ae),ke.set(Ue.slice(0,d),n),Ae=e}else ke[r+t]=Ue[0]},w=e=>{let t=Oe();return 0===t?b(e,!0):void(Ae=t)}}useBuffer(e){// this means we are finished using our own buffer and we can write over it safely
ke=e,_e=new DataView(ke.buffer,ke.byteOffset,ke.byteLength),Ae=0}clearSharedData(){this.structures&&(this.structures=[]),this.typedStructs&&(this.typedStructs=[])}}he=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor/*TypedArray*/,v],fe=[{pack(e,n,r){let s=e.getTime()/1e3;if((this.useTimestamp32||0===e.getMilliseconds())&&0<=s&&4294967296>s){// Timestamp 32
let{target:e,targetView:t,position:r}=n(6);e[r++]=214,e[r++]=255,t.setUint32(r,s)}else if(0<s&&4294967296>s){// Timestamp 64
let{target:t,targetView:r,position:i}=n(10);t[i++]=215,t[i++]=255,r.setUint32(i,4e6*e.getMilliseconds()+(s/1e3/4294967296>>0)),r.setUint32(i+4,s)}else if(isNaN(s)){if(this.onInvalidDate)return n(0),r(this.onInvalidDate());// Intentionally invalid timestamp
let{target:e,targetView:t,position:s}=n(3);e[s++]=212,e[s++]=255,e[s++]=255}else{// Timestamp 96
let{target:r,targetView:i,position:o}=n(15);r[o++]=199,r[o++]=12,r[o++]=255,i.setUint32(o,1e6*e.getMilliseconds()),i.setBigInt64(o+4,BigInt(t(s)))}}},{pack(e,t,n){let r=Array.from(e),{target:s,position:i}=t(this.moreTypes?3:0);this.moreTypes&&(s[i++]=212,s[i++]=115,s[i++]=0),n(r)}},{pack(e,t,n){let{target:r,position:s}=t(this.moreTypes?3:0);this.moreTypes&&(r[s++]=212,r[s++]=101,r[s++]=0),n([e.name,e.message])}},{pack(e,t,n){let{target:r,position:s}=t(this.moreTypes?3:0);this.moreTypes&&(r[s++]=212,r[s++]=120,r[s++]=0),n([e.source,e.flags])}},{pack(e,t){this.moreTypes?S(e,16,t):k(ye?Buffer.from(e):new Uint8Array(e),t)}},{pack(e,t){let n=e.constructor;n!==be&&this.moreTypes?S(e,re.indexOf(n.name),t):k(e,t)}},{pack(e,t){// specific 0xC1 object
let{target:n,position:r}=t(1);n[r]=193}}];let Re=new xe({useRecords:!1});const Ee=Re.pack,Me=Re.pack,{NEVER:Be,ALWAYS:Ce,DECIMAL_ROUND:De,DECIMAL_FIT:Te}=ce,ze=512,Fe=1024;e.ALWAYS=Ce,e.C1=W,e.DECIMAL_FIT=Te,e.DECIMAL_ROUND=De,e.Decoder=J,e.Encoder=xe,e.FLOAT32_OPTIONS=ce,e.NEVER=Be,e.Packr=xe,e.REUSE_BUFFER_MODE=ze,e.Unpackr=J,e.addExtension=O,e.clearSource=m,e.decode=de,e.decodeIter=function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const n=new J(t);let r;const s=e=>{let t;// if there's incomplete data from previous chunk, concatinate and try again
r&&(e=Buffer.concat([r,e]),r=void 0);try{t=n.unpackMultiple(e)}catch(n){if(n.incomplete)r=e.slice(n.lastPosition),t=n.values;else throw n}return t};if("function"==typeof e[Symbol.iterator])return function*(){for(const t of e)yield*s(t)}();return"function"==typeof e[Symbol.asyncIterator]?async function*(){for await(const t of e)yield*s(t)}():void 0},e.encode=Me,e.encodeIter=/**
	 * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer
	 * If the argument is only Async Iterable, the return value will be an Async Iterable.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
	 * @param {options} [options] - msgpackr pack options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
	 */function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof e[Symbol.iterator])return w(e,t);if("function"==typeof e.then||"function"==typeof e[Symbol.asyncIterator])return L(e,t);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},e.isNativeAccelerationEnabled=!1,e.mapsAsObjects=!0,e.pack=Ee,e.roundFloat32=function(e){pe[0]=e;let t=ie[(127&le[3])<<1|le[2]>>7];return(t*e+(0<e?.5:-.5)>>0)/t},e.unpack=ae,e.unpackMultiple=ue,e.useRecords=!1,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=index.min.js.map
